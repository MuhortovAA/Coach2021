-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
уровни изоляций транзакций
Read uncommitted - Уровень, имеющий самую высокую скорость выполнения транзакций но самую плохую согласованность данных 
		 подходит для прогнозирования.
		каждая транзакция видит незафиксированные изменения другой 
		транзакции (феномен грязного чтения) Т1 - записал данные и откатил, Т2 - видит грязные данные
Read committed - Для этого уровня параллельно исполняющиеся транзакции видят только зафиксированные изменения из других 
		транзакций. Таким образом, данный уровень обеспечивает защиту от грязного чтения.Т1 - записал данные, Т2 - прочитал их 
Repeatable read - Т2 - будет ждять пока Т!- зафикисрует данные. При repeatable read в данном случае возникнет lock и активация пройдет единожды, 
		а в предыдущих 2 уровнях возможна многократная активация.
Serializable - медленная скорость транзакций из-за частых lock'ов. Пока Т2 не завершит свою работу, мы не сможем работать с данными, 
		которые она прочитала.
Вываод - задачи, в которых поиск лучшего баланса между высокой согласованностью данных или скоростью выполнения транзакций может помочь решить некоторую прикладную задачу.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Middleware -  это фрагмент кода в конвейере приложения, используемый для обработки запросов и ответов.  
                     может быть встроенным как часть платформы .NET Core, добавляемым через пакеты NuGet
                     паттерн - цепочка обязанностей
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Абстрагирование – это способ выделить набор значимых характеристик объекта, исключая из рассмотрения незначимые. Соответственно, абстракция – это набор всех таких характеристик.

Инкапсуляция – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя.
Encapsulation is a property of the system that allows you to combine data and methods that work with it in a class and hide implementation details from the user. 

Наследование – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствованной функциональностью. 
Полиморфизм – это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Inversion of Control (инверсия управления) — это некий абстрактный принцип, набор рекомендаций для написания слабо связанного кода. 
						Суть которого в том, что каждый компонент системы должен быть как можно более изолированным от других, не полагаясь в своей работе на детали конкретной реализации других компонентов.
Dependency Injection (внедрение зависимостей) — это одна из реализаций этого принципа (помимо этого есть еще Factory Method, Service Locator).
IoC-контейнер — это какая-то библиотека, фреймворк, программа если хотите, которая позволит вам упростить и автоматизировать написание кода с использованием данного подхода на столько, на сколько это возможно. 
		Ninject
		Unity

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

- Параллельные и асинхронные концепции и паттерны
	- классы Task (задача) и Thread (поток): описание, отличия
		Task - это тип, представляющий задачу, которую надо выполнить.
		Thread - это тип, представляющий работника, который может выполнить задачу.

		Для асинхронного сервера лучше использовать таски, т.к. они будут автоматом распределены между доступными работниками. 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	- внутреннее устройство async/await (можно взять, например, отсюда https://devblogs.microsoft.com/premier-developer/dissecting-the-async-methods-in-c/)
https://www.youtube.com/watch?v=eip2Xjrzp9g
http://losev-al.blogspot.com/2012/09/async-await.html
https://metanit.com/sharp/tutorial/13.3.php

		- StateMachine (что будет, если в методе 2 или больше await? Будет ли столько же экземпляров StateMachine?)
		- TaskScheduler		- служит для передечи текущего контекста синхронизации между задачами

дефолтный шедулер.	ThreadPool.TaskScheduler
конкарент pair

*		- SynchronizationContext	- https://habr.com/ru/post/482354/
		- метод ConfigureAwait (почему туда чаще всего передается false и что он делает?)	- https://habr.com/ru/post/482354/

TaskWaiter
getAwaiter - 
unsaveandcompleate

			ConfigureAwait (false) НЕ рагантирует, что обратный вызов не будет выполнен в исходном контексте.
					захватывать или нет контекст операции

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	- в чем проблема async-методов, которые возвращают void		- https://andrey.moveax.ru/post/csharp-do-not-user-async-void
								- не поймать исключения с таких методах. Эти исключения можно наблюдать, используя AppDomain.UnhandledException или аналогичное событие захвата всего (catch-all event) для GUI/ASP.NET-приложений

								- Невозможно определить когда выполнение завершится. Async void-методы будут уведомлять свои SynchronizationContext при запуске и окончании, но собственный SynchronizationContext — слишком сложное решение для обычного прикладного кода.
		- в каких случаях применим async void		- обработчики событий
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	- синхронизация потоков, примитивы синхронизации: отличия, варианты использования

Semaphore - Ограничивает число потоков, которые могут одновременно обращаться к ресурсу или пулу ресурсов.
SemaphoreSlim - Представляет упрощенную альтернативу семафору Semaphore, ограничивающему количество потоков, которые могут параллельно обращаться к ресурсу или пулу ресурсов.
	В отличие от Semaphore класса, SemaphoreSlim класс не поддерживает именованные системные семафоры. 
Monitor - предоставляет монопольный доступ к общему ресурсу. 
		работает на уровне CLR
Mutex - предоставляет монопольный доступ к общему ресурсу. 
		работает на уровне операционной системы

	- конкуретные коллекции: какие бывают, зачем нужны (не забыть про BlockingCollection<T>)	https://habr.com/ru/post/473352/
		- потокобезопасные коллекции
		
		ConcurrentDictionary
		ConcurrentBag - по сути как лист. коллекция значений
		ConcurrentStack 
		ConcurrentQueue
		BlockingCollection - пишут / достает
		Partitioner, OrderablePartitioner, EnumerablePartitionerOptions

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	- методы 
			Task.WaitAll	- ожидает выполнения нескольких задач	- это блокирующий вызов
			Task.WhenAll 	- Получить результаты нескольких задач	- не - код продолжит выполняться
						используйте which когда:
						    WaitAll когда не может продолжаться без результата
						    WhenAll когда что просто быть уведомленным, а не заблокированным

			Task.WaitAny	- Ожидать завершения любой задачи. исключения не поймать
			Task.WhenAny 	- 

public static void WaitAll (params System.Threading.Tasks.Task[] tasks);
public static int WaitAny (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);

public static System.Threading.Tasks.Task WhenAll (System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task> tasks);
public static System.Threading.Tasks.Task<System.Threading.Tasks.Task> WhenAny (System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task> tasks);

		- что произойдет при возникновении исключения в одной из задач
Task.WaitAll выдает AggregateException когда любая из задач бросает, и вы можете проверить все брошенные исключения. 
await на await Task.WhenAll разворачивает и только первое исключение.


Task.WaitAll		- все брошенные исключения
Task.WhenAll		- только первое исключение. но все есть в свойстве Exception задачи Task
Task.WaitAny		- исключения не поймать
Task.WhenAny 		- исключения не поймать

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
сложность алгоритмов	- https://habr.com/ru/post/104219/
			- https://www.bigocheatsheet.com/

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

- Строки и класс String (mutable тип)
	- Почему нужно использовать StringBuilder	- https://docs.microsoft.com/ru-ru/dotnet/standard/base-types/stringbuilder
							- https://zen.yandex.ru/media/id/5d33234f31878200acc7007f/string-vs-stringbuilder-kogda-chto-ispolzovat-obzor-stringbuilder-5d9dcc2fe4fff000aefa0149
	- Что такое интернирование строк (методы string.Intern и string.IsInterned)	- https://habr.com/ru/post/224281/
		String.Intern() Если эта строка уже находится в пуле интернирования, метод возвращает ссылку на эту строку. Если её еще не нет, он добавляет строку в пул и возвращает на неё ссылку.
		String.IsInterned(). принимает ссылку на объект строки. Если эта строка находится в пуле интернирования, он возвращает ссылку на интернированную строку строки, если она еще не находится в пуле интернирования, то метод возвращает null.
	- Методы string.Split, string.Substring ("есть строка, как достать какую-то часть строки?")	- https://docs.microsoft.com/ru-ru/dotnet/api/system.string.split?view=netframework-4.8
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

- Структуры данных
	- HashSet<T>, SortedSet<T>		- https://professorweb.ru/my/csharp/charp_theory/level12/12_12.php
			Коллекция, содержащая только отличающиеся элементы, называется множеством (set). Оба они реализуют интерфейс ISet<T>. 
			HashSet<T> содержит неупорядоченный список различающихся элементов, 
			SortedSet<T> элементы упорядочены.
принимает интерфейс IEqualityComparer

	- Queue<T>, 	?FIFO			- https://docs.microsoft.com/ru-ru/dotnet/api/system.collections.generic.queue-1?view=netframework-4.8
		Enqueue / Dequeue
	- Stack<T> 	LIFO			- https://docs.microsoft.com/ru-ru/dotnet/api/system.collections.generic.stack-1?view=netframework-4.8
		Push / Pop
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

- Делегаты и события
	- просто рассказать что это, как используется		
		Делегаты
		- https://metanit.com/sharp/tutorial/3.13.php
		* Делегаты представляют такие объекты, которые указывают на методы. То есть делегаты - это указатели на методы и с помощью делегатов мы можем вызвать данные методы.
			определена определенная сигнатура

		события
		- https://metanit.com/sharp/tutorial/3.14.php
		* События сигнализируют системе о том, что произошло определенное действие. И если нам надо отследить эти действия, то как раз мы можем применять события.
			Add/Remove/+=
			можно переопределить методы Add/Remove
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

- EF Core
	- разница между IEnumerable<T> и IQueryable<T>
			IQueryable выполняет запрос с фильтрами, тогда как IEnumerable сначала выполняет запрос, а затем фильтрует данные на основе условий.
IEnumerable<T>  - данные в памяти
IQueryable<T> - данные и в памяти и нет

	- DbSet<T> (что это, зачем)	DbSet/DbSet<TEntity>: представляет набор/коллекция сущностей, хранящихся в контексте источника данных
репозеторий
unitOfWork

свойство Local - объект через который можно получить локальную коллекцию.

**********************
переход о стеку состояний
	- added/removed/updates/...
**********************

	- вполне возможны более глубокие вопросы

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

- Expression<T> и деревья выражений
		Тип Expression позволяет представить выражение/алгоритм как данные, организованные в виде древовидной структуры, к которой пользователь имеет доступ. 
		Древовидный способ организации информации об алгоритме и название класса и дают нам «деревья выражений»

	- в чем разница между Func<T> и Expression<Func<T>>	- https://coderoad.ru/2664841/Разница-между-выражением-Func-и-функцией

			Expression<Func<...>> - это дерево выражений, представляющее исходный код (он хранится в древовидной структуре данных, которая очень близка к исходному коду C#). 
						В этой форме вы можете анализировать исходный код, а такие инструменты, как LINQ-SQL, могут переводить дерево выражений (исходный код) на другие языки 
						(например, SQL в случае LINQ-SQL, но вы также можете использовать, например, JavaScript).

			Func<...> - это обычный делегат, который можно выполнить. В этом случае компилятор компилирует тело функции на промежуточный язык (IL) точно так же, как при компиляции стандартного метода.

			Стоит отметить, что Expression<..> имеет метод Compile , который компилирует выражение во время выполнения и генерирует Func<...>, поэтому существует преобразование от первого к второму 
			(с некоторыми затратами на производительность). 
			Однако никакого преобразования из второго в первый не происходит, потому что как только вы получаете IL, очень трудно (невозможно) восстановить исходный исходный код.

	- можни ли перейти от Expression<Func<T>> к Func<T>? 	- да можно. вызвав Compile метод который компилирует дерефо в IL код
			А наоборот?				- нет. невозможно обратно из IL кода построить дерево.
								- сложно но можно. смотрел на DotNexd доклад Максима Аршинова

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

- Redis - хранение в памяти
	- типы данных
	- возможные операции с ними

основано на ключ/значение

# Redis - https://club.cnews.ru/blogs/entry/import_redis_podrobnyj_obzor_2ac6

## Data types

- strings
- lists
- sets
- sorted sets
- hashes
- bitmaps
- geospatial indexes
- streams

	- expire. задается время жизни для всего
		два времени жизни. абсолютное/слайдинг экспирэйшен

****************************
-
Размер БД ограничен доступной памятью
	Шардинг (техника масштабирования) ведет к увеличению задержки
Это NoSQL - никакого языка SQL
	LUA скриптинг в качестве альтернативы
Это нереляционная СУБД!
Нет сегментации на пользователей или группы пользователей. Отсутствует контроль доступа
	Доступ по общему паролю. Что скажут ваши безопасники?

+
Скорость
	Хранение данных в памяти делает быстрее работу с ними
Скрипты на LUA
	Выполнение прямо в памяти, опять же, ускоряет работу
Удобные форматы запросов/данных
	Geospatial – геоданные (высота, ширина, долгота и так далее)
	Hyperloglog – статистическе алгоритмы
	Hash – если коротко, то хэш в Redis делают между строковыми полями и их значениями
Алгоритмы устаревания данных

****************************
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


- MongoDB	https://zen.yandex.ru/media/mcs/v-chem-osobennosti-mongodb-i-kogda-eta-baza-dannyh-vam-podhodit-rukovodstvo-dlia-novichkov-5ecc2f82b0782247ca175e86
   - что это, преимущества и недостатки, основные концепции
			— документоориентированная система управления базами данных с открытым исходным кодом. Для хранения данных используется JSON-подобный формат.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

- ASP.NET Core
	- класс Controller (для чего, какие основные свойства (Properties) у него есть)	- https://docs.microsoft.com/ru-ru/aspnet/core/mvc/controllers/actions?view=aspnetcore-5.0
		ModelState
		User
		HttpContext
		Session
		Request
		....
	- HttpRequest (какую информацию содержит, зачем там ContentType)
		HttpRequest - Позволяет ASP.NET считывать значения HTTP, отправляемые клиентом во время веб-запроса.
		ContentType - Получает или задает тип MIME содержимого входящего запроса.

	- Middleware	- https://habr.com/ru/company/otus/blog/528692/
		Middleware (промежуточное или связующее программное обеспечение) — это фрагмент кода в конвейере приложения, используемый для обработки запросов и ответов.
		настраиваются в методе Сonfigure класса запуска приложения (Startup)
	- MVC request pipeline
		https://docs.microsoft.com/ru-ru/aspnet/mvc/overview/getting-started/lifecycle-of-an-aspnet-mvc-5-application
		https://habr.com/ru/post/62694/
ЭТАП 1: IIS
ЭТАП 2: МАРШРУТИЗАЦИЯ (CORE ROUTING)
	• Система маршрутизации сопоставила входящий URL с конкретным маршрутом и подготовила объект, содержащий контекст запроса. 
	• Выбранный из RouteTable.Routes маршрут обозначил обработчик MvcRouteHandler для обработки запроса.
	• MvcRouteHandler использовал контекст запроса и фабрику контроллеров для того, чтобы выбрать и вызвать соответствующий контроллер.
ЭТАП 3: КОНТРОЛЛЕРЫ И ДЕЙСТВИЯ (CONTROLLERS AND ACTIONS)
	• Контроллер вызвал один из своих методов действий.
ЭТАП 4: РЕЗУЛЬТАТЫ ДЕЙСТВИЙ И ПРЕДСТАВЛЕНИЯ (ACTION RESULTS AND VIEWS)
	• Метод действия вернул объект ActionResult.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

- Базы данных
	- индексы
		структура данных - дерево
			кластеризованный - узел - экземпляр данных
			не кластерный - ссылка на данные
*************************
Покрывающий (covering) индекс - это индекс, которого достаточно для ответа на запрос вовсе без обращения к самой таблице. 
				В самом индексе хранится достаточно данных для ответа на запрос и, хоть и возможно по индексу достать всю строку данных - это просто не нужно.
*************************

	- профилирование и отладка
	- отношения

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

- REST	
	- что это, основные принципы	- https://ru.wikipedia.org/wiki/REST
					- https://dashvlas.com/blog/rest
					архитектурный стиль взаимодействия компонентов распределённого приложения в сети.

Client-Server. Отделяя пользовательский интерфейс от хранилища данных, мы улучшаем переносимость пользовательского интерфейса на другие платформы и улучшаем масштабируемость серверных компонент засчёт их упрощения.
Stateless (без состояния). Каждый запрос от клиента к серверу должен содержать в себе всю необходимую информацию и не может полагаться на какое-либо состояние, хранящееся на стороне сервера. Таким образом, информация о текущей сессии должна целиком храниться у клиента.
Cacheable (кэшируемость). Это ограничение требует, чтобы для данных в ответе на запрос явно было указано -- можно их кэшировать или нет. Если ответ поддерживает кэширование, то клиент имеет право повторно использовать данные в последующих эквивалентных запросов без обращения на сервер.
Uniform interface (единообразие интерфейса). Если применить к систем инженерный принцип общности/единообразия, то архитектура всего приложения станет проще, а взаимодействие станет прозрачнее и понятнее. 
Для выполнения этого принципа необходимо придерживаться нескольких архитектурных ограничений. 
REST накладывает на интерфейс четыре ограничения: 
1) идентичность ресурсов; 
2) манипуляция над ресурсами через представление; 
3) исчерпывающие, понятные человеку сообщения; 
4) гипермедиа (hypermedia) как движок для состояния приложения (HATEOAS) -- ссылки на другие ресурсы внутри приложения.

Layered system (многоуровневая система). Многоуровневость достигается засчёт ограничения поведения компонентов таким образом, что компоненты "не видят" другие компоненты, кроме расположенных на ближайших уровнях, с которыми они взаимодействуют.
Code on demand (код по мере необходимости, необятельно). REST позволяет наращивать функциональность клиентского приложения по мере необходимости при помощи скачивания и исполнения кода в виде апплетов или скриптов. Это упрощает клиентские приложения, уменьшая количество заранее написанных возможностей.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

- Kafka			- распределённая, горизонтально масштабируемая система обработки сообщений.

			- https://habr.com/ru/company/piter/blog/352978/

		Сообщения (messages) записываются по разделам (partition) темы (topic) и хранятся в течении заданного периода.

		Приложения (генераторы) посылают сообщения (записи) на узел Kafka (брокер), и указанные сообщения обрабатываются другими приложениями, так называемыми потребителями. 
		Указанные сообщения сохраняются в теме, a потребители подписываются на тему для получения новых сообщений.


		consumers/producer

******************
группы consumers


10 consumers
2 partition
2 работают / 8 ждут

******************


Kafka VS RabbitMQ - https://www.bigdataschool.ru/blog/kafka-vs-rabbitmq-big-data.html

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

- RabbitMQ (AMQP)
		- https://habr.com/ru/post/489086/
		- https://habr.com/ru/post/488654/
		- https://habr.com/ru/post/490960/
	- что это, зачем
*******************
	- основные концепции (exchange, binding, queue)
		producer — отправитель сообщения;
		message — само сообщение;
		exchange — пункт роутинга сообщений (здесь мы можем указать, куда какое сообщение должно пойти);
			Direct exchange - спользуется, когда нужно доставить сообщение в определенные очереди. 
			Topic exchange – аналогично direct exchange дает возможность осуществления выборочной маршрутизации путем сравнения ключа маршрутизации. 
					Но, в данном случае, ключ задается по шаблону. 
			Fanout exchange – все сообщения доставляются во все очереди даже если в сообщении задан ключ маршрутизации.
			Headers exchange — направляет сообщения в связанные очереди на основе сравнения пар (ключ, значение) свойства headers привязки и аналогичного свойства сообщения. 
						headers представляет собой Dictionary<ключ, значение>. 
			* Consistent-hashing exchange (exchange с согласованным хешированием) – используется, когда есть несколько очередей, являющихся потенциальными получателями сообщения, 
							и когда нужно сбалансировать нагрузку между ними. Связь сообщения с очередью происходит по весу (условное строковое значение от 0 - n). 
		queue — сама очередь из сообщений;
		consumer — исполнитель, который из этой очереди что-то заберёт и что-то сделает.
*******************
	- типы exchange
	- основные стратегии передачи сообщений (one-way, worker queues, pub/sub, RPC)


RabbitMQ – это программный брокер сообщений на основе стандарта AMQP, написанный на языке Erlang и состоящий из следующих основных компонентов
    * Mnesia – распределенная СУБД реального времени для хранения сообщений, предоставляющая уровень транзакций и распределённого выполнения
    * сервер
    * библиотеки поддержки протоколов HTTP, XMPP и STOMP, клиентские библиотеки AMQP для Java и .NET Framework
    * различные плагины (для мониторинга и управления через HTTP и веб-интерфейс, для передачи сообщений между брокерами и др.)

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


- gRPC			- https://habr.com/ru/company/infopulse/blog/265805/
			- https://dev-gang.ru/article/czto-takoe-grpc-objasnenie-buferov-protokola-potokovoi-peredaczi-i-arhitektury-6huania9hr/
			- https://medium.com/maddevs-io/introduction-to-grpc-6de0d9c0fe61

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


https://habr.com/en/company/yandex/blog/265569/



