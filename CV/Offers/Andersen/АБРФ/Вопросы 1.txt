- IDisposable 
	- для чего вообще нужно высвобождать ресурсы? что тогда высвобождает CLR
	- нужно понимать что объект реализующий IDisposable и у которого дергается метод Dispose автоматически попадает во второе поколение GC
	- нужно понимать что нельзя в using (var = new A()){...} инстанциировать A() если он не реализует IDisposable
	- во что разворачивается using () {...}
	

- Параллельные и асинхронные концепции и паттерны
	- классы Task и Thread: описание, отличия
	- что такое TreadPool чем он полезен?
	- можно ли зная кол-во подключений сделать нужный объем Thread и каждую новую сессию обрабатывать, в чем выигрыш и какие недостатки по сравнению с асинхронной работой? (коротко - выигрыш по скорости, т.к. нам не нужно переключаться между потоками, но проигрышь по памяти так как каждый поток будет корнем для GC, для каждого потока содается свой стек в 1Мбайт. Если есть достаточный опыт с PLINQ или Parallel.For Parallel.Foreach можно привести их как вариант решения -- они будут юзать TreadPool)
	- знать что такое DeadLock как его можно поймать (я например всегда избегаю taskwork.Wait() taskwork.Result даже на NetCore, хотя там и выпилили SynchronizationContext и вроде как дедлоки не возможны, но это дело привычки)
	- варианты сделать таску из метода/лямбды (Task.Run(() => {....})), перегнать какое то значение в таску через метод Task.FromResult - полезно например в тетрарных операторах когда один из вариантов таска, а второе значение константа (Task<DateTime> task = DateTime.Now == newYear ? Task.FromResult(DateTime.Now) : getNewYearAsync()  --- задача 3) 
	- внутреннее устройство async/await (можно взять, например, отсюда https://devblogs.microsoft.com/premier-developer/dissecting-the-async-methods-in-c/ либо https://www.youtube.com/watch?v=fi_N_ghu4Ug)
	- в чем проблема async-методов, которые возвращают void (как и все методы async они начинают сихроное выполнение до первого await а дальше не дожидаясь исполнения возвращают исполнение в родительский поток таким образом выполнение напоминает концепцию выстрелил и забыл)
		- в каких случаях применим async void (для асинхоронных обработчиков событий)
	- синхронизация потоков, примитивы синхронизации: отличия, варианты использования
		- Знать что lock это синтаксический сахар и разворачивается в Monitor.
		- значть что lock принимает object и если мы передадим value type то произойдет боксинг и в lock каждый раз будет передаваться НОВАЯ ссылка на переменную в куче (Задача 2).
		- понимать что такое атомарная операция и чем опасны для многопоточности НЕатомарные операции
		- конкуретные коллекции: какие бывают, зачем нужны
		- знать что Semaphore  не применим в linux (там юзается SemaphoreSlim), так как использует именованные симофоры Windows. 
	
- String
	- помнить что string - это reference type, соответственно хранит в себе ссылку в метод передается по ссылке, если внутри метода будет присвоено значение и аргумент функции не помечен ref поменяется ли значение "внешней" переменной (задача 1)?
	- помнить что string imutable т.е. при добавлении даже одной буквы будет создан новый объект на куче и ссылка на него будет помещена в переменную, поэтому при интенсивной работе со строками есть резон юзать StringBuilder.
	- помнить про таблицу интернирования строк и соответствующие методы. знать что от версии к версии дефолтное поведение компилятора в отношении интернирования строк может меняться (об этом сказано в CLR via C# Рихтера) и на это поведение стоит расчитывать ТОЛЬКО если самостоятельно дергаются методы string.Intern и string.IsInterned
	
- Понимание Solid принципов:
	- есть задача на нарушение принципа подстановки Барбары Лисков
	- есть задача где резонно перевести switch case в отдельный метод интерфейса и добавить разные реализации в зависимости от литерала страны ("RU", "EN"...)

- Понимание IoC (внедрение зависимости и инверсия управления)
	- есть задача в которой резонно переделать статический класс под сервисный класс так как это позволит уменьшить риск "утечки памяти" (статические классы являются корнями для GC он их не собирает)

- RabbitMQ (AMQP)
	- что это, зачем
	- основные концепции (exchange, binding, queue)
	- типы exchange
	- основные стратегии передачи сообщений (one-way, worker queues, pub/sub, RPC)

ВОЗМОЖНО:

- Делегаты и события
	- просто рассказать что это, как используется

- EF Core
	- разница между IEnumerable<T> и IQueryable<T>
	- DbSet<T> (что это, зачем)

- Expression<T> и деревья выражений
	- в чем разница между Func<T> и Expression<Func<T>>
	- можни ли перейти от Expression<Func<T>> к Func<T>? А наоборот?

- Redis
	- типы данных
	- возможные операции с ними

- ASP.NET Core
	- класс Controller (для чего, какие основные свойства (Properties) у него есть)
	- HttpRequest (какую информацию содержит, зачем там ContentType)
	- Middleware
	- MVC request pipeline

- Базы данных
	- индексы (типы, знать что за частую индекс это отдельная структура которая предстваляет из себя бинарное дерево поиска и поэтому ускорязет запросы, НО добавлени нового элемента в базу требует перестроить дерево, соотственно если индексов много это накладные расходы будут большими и это не желательно.)
	- знать что такое покрывающий индекс.